Download Link: https://assignmentchef.com/product/solved-solvedpart-a-the-colourme-game
<br>
Task 1 (3 Marks) Your UPI should be displayed inside the title bar of the window. To do this, open the A2PartA.java application file and insert your UPI, e.g., JFrame colourMe = new A2JFrame(“A2 Part A by abcd001”, … ); Task 2. The ColourMe game (37 Marks) The aim of this game is to fill the whole game board with the same colour in less than 25 moves. The board is made up of six colour buttons at the top of the JPanel and a grid of cells and, initially, each cell is assigned a random colour (there are 6 possible colours). Each cell has 4 adjacent ‘connected’ neighbours (above, to the right, below, to the left) except for the border cells. The user selects a colour by pressing one of the colour buttons and, starting from the top-left cell, all the cells adjacent to the top-left cell with the same colour as the top-left cell, change to the new colour selected by user.Slowly by selecting different colours the user changes the whole board to one single colour. For example, given the following section of the ColourMe board: … and so on until the board becomes more and more filled with the same colour:Task 2 (37 Marks)Task 2 has been broken up into five stages. The classes in this program have been completed except for the BlockOfCells class (and part of the JPanel class – see Task 3) which you need to complete. The BlockOfCells class represents the whole grid of coloured cells and handles all the actions to do with managing the individual cells. The skeleton of the BlockOfCells class is shown on the next page:public class BlockOfCells { public static final int NUMBER_OF_ROWS = … public static final int NUMBER_OF_COLS = … public static final int CELL_SIZE = A2Constants.CELL_SIZE; public static final Rectangle GAME_AREA = … private Cell[][] cellBlock; public BlockOfCells() { … } cellBlock = new Cell[NUMBER_OF_ROWS][NUMBER_OF_COLS]; createTheCells(cellBlock); } private void createTheCells(Cell[][] cellBlock) { int x = GAME_AREA.x; int y = GAME_AREA.y; for(int i = 0; i &lt; cellBlock.length; i++) { x = GAME_AREA.x; for(int j = 0; j &lt; cellBlock.length; j++) { cellBlock[i][j] = new Cell(x, y); x = x + CELL_SIZE; } y = y + CELL_SIZE; } } //------------------------------------------------------- // Stage 2 (4 marks) Methods to do with the colour index of // each cell //------------------------------------------------------- public int getCellColourIndex(int row, int col) { ... } public void setCellColourIndex(int row, int col, int colourIndex) { ... } //------------------------------------------------------- // Stage 3 (4 marks) Reset hasBeenVisited for all cells //------------------------------------------------------- private void resetAllCellHasBeenVisited() { ... } //------------------------------------------------------- // Stage 5 (10 marks) Recursive method which returns the number of // cells connected (i.e., with the same colour index as the // top left cell (0, 0)) //------------------------------------------------------- public int getNumberOfConnectedCells() { int colourIndex = getCellColourIndex(0, 0); resetAllCellHasBeenVisited(); return getNumberOfCellsInUserBlock(0, 0, colourIndex); } private int getNumberOfCellsInUserBlock( ... ) { ... } //------------------------------------------------------- // Stage 4 (10 marks) Recursively updates the colour of all cells // connected (i.e., with same colour index as the top left // cell (position 0, 0)) //------------------------------------------------------- public void updateConnectedCells(int userColourIndex) { int colourToChangeIndex = getCellColourIndex(0, 0); resetCellHasBeenVisited(); updateUserAreaColours(0, 0, getCellColourIndex, colourToChangeIndex); } private void updateUserAreaColours( ... ) { ... } //------------------------------------------------------- // Stage 6 (4 marks) returns a String with all the colour // indexes of the cells concatenated, row by row //------------------------------------------------------- public String colourIndexesToString() { ... } COMPSCI 105 - A2 4 //------------------------------------------------------- // Stage 1 (5 marks) Draw the 2D array of coloured cells //------------------------------------------------------- public void drawCells(Graphics g) { ...Notes on Task 2 Stage 1 drawCells() – 5 marks The BlockOfCells class has one instance variable: private Cell[][] cellBlock; which stores the grid of Cell objects. This method draws all the Cell objects in the grid. Once you have completed stage 1, the user should see all the coloured cells. The cells are randomly assigned colours. Please note that the user can play a new game by pressing the 'n' (or 'N') key hence you can see a new randomly coloured grid by pressing the 'n' key. Stages 2 and 3 see the skeleton code above - 8 marks Stage 4 updateUserAreaColours() – 10 marks This instance method is called whenever the user chooses a new colour by pressing one of the Colour buttons. This method should update the colour of all the cells connected to the top left cell (0, 0) to the new colour selected by the user. Note that each cell has 4 adjacent (i.e., connected) neighbours (except for the border cells). Note that each cell stores the index of its fill colour (index of one of the colours in the COLOURS array). To complete this method you should use a recursive algorithm. Once you have completed stage 4, the user should be able to fill the grid with colour by pressing the Colour buttons. Stage 5 getNumberOfCellsInUserBlock() – 10 marks This instance method is called after the colour in the cells has been changed (i.e., after the user has pressed one of the Colour buttons). This method returns the number of cells which have the same colour as the top left cell (0, 0) and are connected to the top left cell. Note that each cell has 4 adjacent (i.e., connected) neighbours (except for the border cells). Note that each cell stores the index of its colour (index of one of the colours in the COLOURS array). To complete this method you should use a recursive algorithm. Once you have completed stage 5, you should see the current number of connected cells in the JPanel on the right of the grid of cells. This number should change depending on how many connected cells there are.Task 3 (5 Marks)In the A2JPanel class complete the storeGame() method. This method writes the current state of the ColourMe game to the file (the name of the file where the game is stored is passed as a parameter to the storeGame() method). The format of the file is as shown in the screenshot below. The first line of the text file contains the values of the four instance variables: gameHasEnded (boolean), userHasWon (boolean), turnsRemaining (int) and numberConnected (int) A new line follows and then the indexes of all the colours of each cell (taken row by row) are stored in the file (the colourIndexesToString() method of the BlockOfCells class is useful here).Please Note Now that you have completed task 3, the user is able to (see the code in the keyPressed() method in the JPanel class): save the current game by pressing the 's' (or 'S') key, load the most recently saved game by pressing the 'l' (or 'L') key, and reload the current game from the beginning by pressing the 'r' (or 'R') key. Note that the initial state of the current game is stored in the text file, "restartGame.txt", and the last saved game is stored in the text file, "currentGameState.txt". You have now completed part A of this assignment.FIND ATTACHED FOR SOLUTION